package net.aspw.client.features.module.impl.exploit

import io.netty.buffer.Unpooled
import net.aspw.client.Client
import net.aspw.client.event.*
import net.aspw.client.features.module.Module
import net.aspw.client.features.module.ModuleCategory
import net.aspw.client.features.module.ModuleInfo
import net.aspw.client.features.module.impl.combat.KillAura
import net.aspw.client.features.module.impl.movement.Flight
import net.aspw.client.features.module.impl.movement.Speed
import net.aspw.client.features.module.impl.player.Scaffold
import net.aspw.client.utils.*
import net.aspw.client.utils.misc.RandomUtils
import net.aspw.client.utils.render.RenderUtils
import net.aspw.client.utils.render.Stencil
import net.aspw.client.utils.timer.MSTimer
import net.aspw.client.value.BoolValue
import net.aspw.client.value.IntegerValue
import net.aspw.client.value.ListValue
import net.aspw.client.visual.font.Fonts
import net.aspw.client.visual.hud.element.elements.Notification
import net.minecraft.client.gui.ScaledResolution
import net.minecraft.entity.Entity
import net.minecraft.entity.item.EntityBoat
import net.minecraft.entity.player.PlayerCapabilities
import net.minecraft.init.Items
import net.minecraft.item.ItemSword
import net.minecraft.network.Packet
import net.minecraft.network.PacketBuffer
import net.minecraft.network.play.INetHandlerPlayServer
import net.minecraft.network.play.client.*
import net.minecraft.network.play.client.C03PacketPlayer.*
import net.minecraft.network.play.server.*
import net.minecraft.util.BlockPos
import net.minecraft.util.EnumFacing
import java.awt.Color
import java.io.ByteArrayOutputStream
import java.io.DataOutputStream
import java.io.IOException
import java.util.*
import java.util.concurrent.LinkedBlockingQueue
import kotlin.math.round
import kotlin.math.sqrt


@ModuleInfo(name = "Disabler", category = ModuleCategory.EXPLOIT)
class Disabler : Module() {

    private val basic = BoolValue("Basic", false)
    private val vanilladesync = BoolValue("Vanilla-Desync", false)
    private val silentaccept = BoolValue("Silent-Accept", false)
    private val packetinvade = BoolValue("Packet-Invade", false)
    private val coldpvp = BoolValue("ColdPvP-KitPvP-Full", false)
    private val funcraftstaff = BoolValue("Funcraft-Staff", false)
    private val blockdrop = BoolValue("BlockDrop", false)
    private val hycraft = BoolValue("Hycraft", false)
    private val inventoryspoof = BoolValue("Inventory-Spoof", false)
    private val tubnet = BoolValue("Tubnet", false)
    private val heirteirac = BoolValue("Heirteir-AC", false)
    private val intave = BoolValue("Intave", false)
    private val jump = BoolValue("Jump", false)
    private val boat = BoolValue("Boat", false)
    private val latestverus = BoolValue("Latest-Verus", false)
    private val verussemi = BoolValue("Verus-Semi", false)
    private val veruscombat = BoolValue("Verus-Combat", false)
    private val gwencombat = BoolValue("Gwen-Combat", false)
    private val spartancombat = BoolValue("Spartan-Combat", false)
    private val pingspoof = BoolValue("Ping-Spoof", false)
    private val flag = BoolValue("Flag", false)
    private val input = BoolValue("Input", false)
    private val payload = BoolValue("Payload", false)
    private val spectate = BoolValue("Spectate", false)
    private val cubecraft = BoolValue("Cubecraft", false)
    private val mushmc = BoolValue("MushMC", false)
    private val universocraft = BoolValue("Universocraft", false)
    private val buzzsemi = BoolValue("Buzz-Semi", false)
    private val vulcancombat = BoolValue("Vulcan-Combat", false)
    private val vulcanstrafe = BoolValue("Vulcan-Strafe", false)
    private val vulcanautoblock = BoolValue("Vulcan-AutoBlock", false)
    private val matrix = BoolValue("Matrix", false)
    private val oldmatrix = BoolValue("Old-Matrix", false)
    private val oldwatchdog1 = BoolValue("Old-Watchdog1", false)
    private val oldwatchdog2 = BoolValue("Old-Watchdog2", false)

    private val linkedQueue: Queue<Packet<*>> = LinkedBlockingQueue()
    private val timer = TimeHelper()

    private val minpsf: IntegerValue = object :
        IntegerValue("PingSpoof-MinDelay", 200, 0, 10000, "ms", { pingspoof.get() }) {
        override fun onChanged(oldValue: Int, newValue: Int) {
            val v = maxpsf.get()
            if (v < newValue) set(v)
        }
    }
    private val maxpsf: IntegerValue = object :
        IntegerValue("PingSpoof-MaxDelay", 250, 0, 10000, "ms", { pingspoof.get() }) {
        override fun onChanged(oldValue: Int, newValue: Int) {
            val v = minpsf.get()
            if (v > newValue) set(v)
        }
    }
    private val psfStartSendMode = ListValue(
        "PingSpoof-StartSendMode",
        arrayOf("All", "First"),
        "All",
        { pingspoof.get() })
    private val psfSendMode =
        ListValue("PingSpoof-SendMode", arrayOf("All", "First"), "All", { pingspoof.get() })
    private val psfWorldDelay =
        IntegerValue("PingSpoof-WorldDelay", 15000, 0, 30000, "ms", { pingspoof.get() })

    // flag
    private val flagMode =
        ListValue("Flag-Mode", arrayOf("Edit", "Packet"), "Edit", { flag.get() })
    private val flagTick = IntegerValue("Flag-TickDelay", 25, 1, 200, { flag.get() })
    private val flagSilent = BoolValue("Flag-SilentMode", false, { flag.get() })

    // matrix
    private val matrixNoCheck = BoolValue("Matrix-NoModuleCheck", false, { matrix.get() })
    private val matrixMoveFix = BoolValue("Matrix-MoveFix", true, { matrix.get() })
    private val matrixMoveOnly = BoolValue("Matrix-MoveOnly", false, { matrix.get() })
    private val matrixNoMovePacket = BoolValue("Matrix-NoMovePacket", true, { matrix.get() })
    private val matrixHotbarChange = BoolValue("Matrix-HotbarChange", true, { matrix.get() })

    // vulcancombat
    private val compDecValue = BoolValue("VulcanDecrease", true, { vulcancombat.get() })
    private val statDecValue =
        IntegerValue("VulcanDecreaseDelay", 1500, 500, 2500, { vulcancombat.get() && compDecValue.get() })
    private val dynamicValue = BoolValue("VulcanDynamicDelay", true, { vulcancombat.get() })
    private val decDelayMinValue =
        IntegerValue("VulcanMinDelay", 4500, 2000, 8000, { vulcancombat.get() && dynamicValue.get() })
    private val decDelayMaxValue =
        IntegerValue("VulcanMaxDelay", 5500, 2000, 8000, { vulcancombat.get() && dynamicValue.get() })
    private val minBuffValue = IntegerValue("VulcanMinBuff", 5, 0, 12, { vulcancombat.get() })
    private val noC0BValue = BoolValue("NoC0BPacket", false, { vulcancombat.get() })

    // vulcanstrafe
    private val avoidPhaseBpValue = BoolValue("NoBadPacket", true, { vulcanstrafe.get() })
    private val delayValue = IntegerValue("PacketDelay", 6, 3, 10, { vulcanstrafe.get() })

    // packetinvade
    private val modifyC00Value = BoolValue("Modify-C00", true, { packetinvade.get() })
    private val modifyModeValue = ListValue(
        "Modify-Mode",
        arrayOf("Disturb", "InvalidDisturb", "Invalid", "Drift"),
        "Drift",
        { packetinvade.get() && modifyC00Value.get() })
    private val disturbAmountValue = IntegerValue("Modify-Amount", 128, 1, 256, { packetinvade.get() })
    private val negativeValue = BoolValue("Negative", true, { packetinvade.get() })

    // verus
    private val verusLobbyValue = BoolValue(
        "LobbyCheck",
        false,
        { latestverus.get() })
    private val verusFlagValue = BoolValue("Verus-Flag", true, { latestverus.get() })
    private val verusSlientFlagApplyValue =
        BoolValue("Verus-SilentFlagApply", false, { latestverus.get() })
    private val verusBufferSizeValue =
        IntegerValue("Verus-QueueActiveSize", 300, 0, 1000, { latestverus.get() })
    private val verusFlagDelayValue =
        IntegerValue("Verus-FlagDelay", 40, 40, 120, " tick", { latestverus.get() })
    private val verusAntiFlyCheck = BoolValue("Verus-AntiFlight", true, { latestverus.get() })
    private val verusFakeInput = BoolValue("Verus-FakeInput", true, { latestverus.get() })
    private val verusValidPos = BoolValue("Verus-ValidPosition", true, { latestverus.get() })

    // watchdogold
    private val waitingDisplayMode = ListValue(
        "Waiting-Display",
        arrayOf("Top", "Middle", "Notification", "Chat", "None"),
        "Top",
        { oldwatchdog1.get() })
    private val autoAlert = BoolValue("BanAlert", false, { oldwatchdog1.get() })
    private val rotModify = BoolValue("RotationModifier", false, { oldwatchdog1.get() })
    private val tifality90 =
        BoolValue("Tifality", false, { oldwatchdog1.get() && rotModify.get() })
    private val noMoveKeepRot =
        BoolValue("NoMoveKeepRot", true, { oldwatchdog1.get() && rotModify.get() })
    private val noC03s = BoolValue("NoC03s", true, { oldwatchdog1.get() })
    private val testFeature = BoolValue("PingSpoof", true, { oldwatchdog1.get() })
    private val testDelay =
        IntegerValue("Delay", 400, 0, 1000, "ms", { oldwatchdog1.get() && testFeature.get() })
    private val checkValid =
        BoolValue("InvValidate", true, { oldwatchdog1.get() && testFeature.get() })

    // watchdognew
    private val rotationChanger = BoolValue("RotationDisabler", true, { oldwatchdog2.get() })
    private val c00Disabler = BoolValue("KeepAliveDisabler", false, { oldwatchdog2.get() })
    private val c0BDisabler = BoolValue("C0BDisabler", true, { oldwatchdog2.get() })
    private val watchDogAntiBan = BoolValue("LessFlag", false, { oldwatchdog2.get() })
    private val noC03 = BoolValue("NoC03Packet", true, { oldwatchdog2.get() })
    private val strafeDisabler = BoolValue("StrafeDisabler", true, { oldwatchdog2.get() })
    private val strafePackets =
        IntegerValue("StrafeDisablerPacketAmount", 70, 60, 120, { oldwatchdog2.get() })
    private val timerA = BoolValue("Timer1", true, { oldwatchdog2.get() })
    private val timerB = BoolValue("Timer2", false, { oldwatchdog2.get() })
    private val staffValue = BoolValue("AntiStaff", true, { oldwatchdog2.get() })
    private var x = 0.0
    private var y = 0.0
    private var z = 0.0
    private val packets = LinkedBlockingQueue<Packet<INetHandlerPlayServer>>()
    private val timerCancelDelay = MSTimer()
    private val timerCancelTimer = MSTimer()
    private var timerShouldCancel = true
    private var inCage = true
    private var canBlink = true
    private var lockRotation: Rotation? = null
    private var uid = 0

    // debug
    private val debugValue = BoolValue("Debug", false)

    // sus
    private var rotatingSpeed = 0F

    // variables
    private val keepAlives = arrayListOf<C00PacketKeepAlive>()
    private val transactions = arrayListOf<C0FPacketConfirmTransaction>()
    private val packetQueue = LinkedList<C0FPacketConfirmTransaction>()
    private val anotherQueue = LinkedList<C00PacketKeepAlive>()
    private val playerQueue = LinkedList<C03PacketPlayer>()

    private val packetBus = hashMapOf<Long, Packet<INetHandlerPlayServer>>()
    private val queueBus = LinkedList<Packet<INetHandlerPlayServer>>()
    private val packetBuffer = LinkedList<Packet<INetHandlerPlayServer>>()

    private val posLookInstance = PosLookInstance()

    private val msTimer = MSTimer()
    private val wdTimer = MSTimer()
    private val benTimer = MSTimer()

    private val pulseTimer = MSTimer()
    private var disableLogger = false

    private var alrSendY = false
    private var alrSprint = false
    private var c03Counter = 0

    private var expectedSetback = false

    private var sendDelay = 0
    private var shouldActive = false
    private var benHittingLean = false

    private var transCount = 0
    private var counter = 0
    private var canModify = false

    var shouldModifyRotation = false

    private var lastTick = 0

    private var s08count = 0
    private var ticking = 0
    private var lastYaw = 0F

    private var lastUid = 0
    private var currentTrans = 0

    private var currentDelay = 5000
    private var currentBuffer = 4
    private var currentDec = -1
    private val lagTimer = MSTimer()
    private val decTimer = MSTimer()
    private var runReset = false

    val canModifyRotation: Boolean
        get() = (state && oldwatchdog1.get() && shouldModifyRotation)

    fun isMoving(): Boolean =
        (mc.thePlayer != null && (mc.thePlayer.movementInput.moveForward != 0F || mc.thePlayer.movementInput.moveStrafe != 0F || mc.thePlayer.movementInput.sneak || mc.thePlayer.movementInput.jump))

    fun debug(s: String, force: Boolean = false) {
        if (debugValue.get() || force)
            ClientUtils.displayChatMessage(Client.CLIENT_CHAT + "Â§f$s")
    }

    fun shouldRun(): Boolean =
        mc.thePlayer != null && mc.thePlayer.inventory != null && (!verusLobbyValue.get() || !mc.thePlayer.inventory.hasItem(
            Items.compass
        )) && mc.thePlayer.ticksExisted > 5

    fun isInventory(action: Short): Boolean = action > 0 && action < 100

    override fun onEnable() {
        if (vulcanstrafe.get()) {
            c03Counter = -15
        }

        if (oldwatchdog2.get()) {
            counter = 0
            inCage = true
            x = 0.0
            y = 0.0
            z = 0.0
            timerCancelDelay.reset()
            timerCancelTimer.reset()
        }

        if (boat.get()) {
            debug("Place 2 boats next to each other and right click to use it!")
        }

        if (intave.get()) {
            this.timer.reset()
            this.linkedQueue.clear()
        }

        packetBuffer.clear()
        keepAlives.clear()
        transactions.clear()
        packetQueue.clear()
        anotherQueue.clear()
        playerQueue.clear()
        packetBus.clear()
        queueBus.clear()

        s08count = 0

        pulseTimer.reset()
        msTimer.reset()
        wdTimer.reset()
        benTimer.reset()
        canModify = false
        expectedSetback = false
        shouldActive = false
        alrSendY = false
        alrSprint = false
        transCount = 0
        lastTick = 0
        ticking = 0

        lastUid = 0
        posLookInstance.reset()

        shouldModifyRotation = false
        benHittingLean = false

        rotatingSpeed = 0F
    }

    override fun onDisable() {
        keepAlives.forEach {
            PacketUtils.sendPacketNoEvent(it)
        }
        transactions.forEach {
            PacketUtils.sendPacketNoEvent(it)
        }

        packetBuffer.clear()
        keepAlives.clear()
        transactions.clear()
        packetQueue.clear()
        anotherQueue.clear()
        packetBus.clear()
        lockRotation = null

        if (inventoryspoof.get()) {
            PacketUtils.sendPacketNoEvent(C0DPacketCloseWindow())
        }

        if (vulcancombat.get()) {
            updateLagTime()
            BlinkUtils.releasePacket(packetType = "C0FPacketConfirmTransaction")
            BlinkUtils.setBlinkState(packetTransaction = false)
        }

        if (oldwatchdog1.get()) {
            anotherQueue.forEach { PacketUtils.sendPacketNoEvent(it) }
            packetQueue.forEach { PacketUtils.sendPacketNoEvent(it) }
        }

        if (tubnet.get()) {
            if (mc.thePlayer == null) return
            blink()
        }

        if (pingspoof.get()) {
            // make sure not to cause weird flag
            for (p in queueBus)
                PacketUtils.sendPacketNoEvent(p)
        }
        queueBus.clear()

        msTimer.reset()

        mc.thePlayer.motionY = 0.0
        MovementUtils.strafe(0F)
        mc.timer.timerSpeed = 1F

        shouldModifyRotation = false
    }

    @EventTarget
    fun onWorld(event: WorldEvent) {
        if (vulcanstrafe.get()) {
            c03Counter = -15
        }

        if (oldwatchdog2.get()) {
            counter = 0
            inCage = true
        }

        if (vulcancombat.get()) {
            BlinkUtils.clearPacket(packetType = "C0FPacketConfirmTransaction")
            currentTrans = 0
            updateLagTime()
            runReset = noC0BValue.get()
        }

        packetBuffer.clear()
        transactions.clear()
        keepAlives.clear()
        packetQueue.clear()
        anotherQueue.clear()
        playerQueue.clear()
        packetBus.clear()
        queueBus.clear()
        canModify = false

        s08count = 0

        msTimer.reset()
        wdTimer.reset()
        benTimer.reset()
        expectedSetback = false
        shouldActive = false
        alrSendY = false
        alrSprint = false
        benHittingLean = false
        transCount = 0
        counter = 0
        lastTick = 0
        ticking = 0
        lastUid = 0
        posLookInstance.reset()

        rotatingSpeed = 0F
    }

    @EventTarget
    fun onRender2D(event: Render2DEvent) {
        if (!shouldActive) {
            val sc = ScaledResolution(mc)
            val strength =
                (msTimer.hasTimeLeft(psfWorldDelay.get().toLong()).toFloat() / psfWorldDelay.get().toFloat()).coerceIn(
                    0F,
                    1F
                )

            if (pingspoof.get()) {
                Stencil.write(true)
                RenderUtils.drawRoundedRect(
                    sc.scaledWidth / 2F - 50F,
                    35F,
                    sc.scaledWidth / 2F + 50F,
                    55F,
                    10F,
                    Color(0, 0, 0, 140).rgb
                )
                Stencil.erase(true)
                RenderUtils.drawRect(
                    sc.scaledWidth / 2F - 50F,
                    35F,
                    sc.scaledWidth / 2F - 50F + 100F * strength,
                    55F,
                    Color(0, 111, 255, 70).rgb
                )
                Stencil.dispose()
                Fonts.fontSFUI40?.drawCenteredString(
                    "${
                        (msTimer.hasTimeLeft(psfWorldDelay.get().toLong()).toFloat() / 1000F).toInt()
                    }s left...", sc.scaledWidth / 2F, 41F, -1
                )
            }
            if ((oldwatchdog1.get() && testFeature.get()) && !ServerUtils.isHypixelLobby() && !mc.isSingleplayer
            ) {
                when (waitingDisplayMode.get().lowercase(Locale.getDefault())) {
                    "top" -> {
                        Fonts.minecraftFont.drawString(
                            "Disabling Watchdog...",
                            sc.scaledWidth / 2F - Fonts.minecraftFont.getStringWidth("Disabling watchdog...") / 2F,
                            61.5F,
                            Color(0, 0, 0).rgb,
                            false
                        )
                        Fonts.minecraftFont.drawString(
                            "Disabling Watchdog...",
                            sc.scaledWidth / 2F - Fonts.minecraftFont.getStringWidth("Disabling watchdog...") / 2F,
                            62.5F,
                            Color(0, 0, 0).rgb,
                            false
                        )
                        Fonts.minecraftFont.drawString(
                            "Disabling Watchdog...",
                            sc.scaledWidth / 2F - Fonts.minecraftFont.getStringWidth("Disabling watchdog...") / 2F - 0.5F,
                            62F,
                            Color(0, 0, 0).rgb,
                            false
                        )
                        Fonts.minecraftFont.drawString(
                            "Disabling Watchdog...",
                            sc.scaledWidth / 2F - Fonts.minecraftFont.getStringWidth("Disabling watchdog...") / 2F + 0.5F,
                            62F,
                            Color(0, 0, 0).rgb,
                            false
                        )
                        Fonts.minecraftFont.drawString(
                            "Disabling Watchdog...",
                            sc.scaledWidth / 2F - Fonts.minecraftFont.getStringWidth("Disabling watchdog...") / 2F,
                            62F,
                            Color(220, 220, 60).rgb,
                            false
                        )
                    }

                    "middle" -> {
                        Fonts.minecraftFont.drawString(
                            "Disabling Watchdog...",
                            sc.scaledWidth / 2F - Fonts.minecraftFont.getStringWidth("Disabling watchdog...") / 2F,
                            sc.scaledHeight / 2F + 14.5F,
                            Color(0, 0, 0).rgb,
                            false
                        )
                        Fonts.minecraftFont.drawString(
                            "Disabling Watchdog...",
                            sc.scaledWidth / 2F - Fonts.minecraftFont.getStringWidth("Disabling watchdog...") / 2F,
                            sc.scaledHeight / 2F + 15.5F,
                            Color(0, 0, 0).rgb,
                            false
                        )
                        Fonts.minecraftFont.drawString(
                            "Disabling Watchdog...",
                            sc.scaledWidth / 2F - Fonts.minecraftFont.getStringWidth("Disabling watchdog...") / 2F - 0.5F,
                            sc.scaledHeight / 2F + 15F,
                            Color(0, 0, 0).rgb,
                            false
                        )
                        Fonts.minecraftFont.drawString(
                            "Disabling Watchdog...",
                            sc.scaledWidth / 2F - Fonts.minecraftFont.getStringWidth("Disabling watchdog...") / 2F + 0.5F,
                            sc.scaledHeight / 2F + 15F,
                            Color(0, 0, 0).rgb,
                            false
                        )
                        Fonts.minecraftFont.drawString(
                            "Disabling Watchdog...",
                            sc.scaledWidth / 2F - Fonts.minecraftFont.getStringWidth("Disabling watchdog...") / 2F,
                            sc.scaledHeight / 2F + 15F,
                            Color(220, 220, 60).rgb,
                            false
                        )
                    }
                }
            }
        }
    }

    @EventTarget
    fun onPacket(event: PacketEvent) {
        val packet = event.packet

        if (boat.get()) {
            if (mc.thePlayer.ridingEntity != null) {
                canModify = true
            }

            if (canModify && packet is C03PacketPlayer) {
                packet.onGround = true
            }
        }

        if (universocraft.get()) {
            if (packet is C0FPacketConfirmTransaction) {
                if (mc.thePlayer.onGround) {
                    uid = packet.getUid().toInt()
                    debug("funny 3")
                } else {
                    packet.uid = (uid - 2).toShort()
                    debug("funny 2")
                }
            }
        }

        if (coldpvp.get()) {
            if (packet is C00PacketKeepAlive) {
                event.cancelEvent()
                debug("funny 1")
            }
            if (packet is C0BPacketEntityAction && (packet.action == C0BPacketEntityAction.Action.STOP_SPRINTING || packet.action == C0BPacketEntityAction.Action.START_SPRINTING)) {
                event.cancelEvent()
                debug("funny 2")
            }
            if (packet is C03PacketPlayer) {
                PacketUtils.sendPacketNoEvent(
                    C0CPacketInput(
                        mc.thePlayer.moveStrafing,
                        mc.thePlayer.moveForward,
                        mc.thePlayer.movementInput.jump,
                        mc.thePlayer.movementInput.sneak
                    )
                )
                val x = mc.thePlayer.posX
                val y = mc.thePlayer.posY
                val z = mc.thePlayer.posZ
                val yaw = mc.thePlayer.rotationYaw
                val pitch = mc.thePlayer.rotationPitch
                val ground: Boolean = packet.onGround
                if (packet.isMoving) {
                    PacketUtils.sendPacketNoEvent(C06PacketPlayerPosLook(x, y, z, yaw, pitch, ground))
                }
            }
        }

        if (packetinvade.get()) {
            if (packet is C00PacketKeepAlive && modifyC00Value.get()) {
                when (modifyModeValue.get()) {
                    "Disturb" -> {
                        val amounts = RandomUtils.nextInt(1, disturbAmountValue.get() * 1024)
                        if (negativeValue.get()) {
                            packet.key -= amounts
                        } else {
                            packet.key += amounts
                        }
                    }

                    "InvalidDisturb" -> {
                        val amounts = RandomUtils.nextInt(1024, 2147483647)
                        if (negativeValue.get()) {
                            packet.key -= amounts
                        } else {
                            packet.key += amounts
                        }
                    }

                    "Invalid" -> {
                        packet.key = 0
                    }

                    "Drift" -> {
                        if (negativeValue.get()) {
                            packet.key -= disturbAmountValue.get()
                        } else {
                            packet.key += disturbAmountValue.get()
                        }
                    }
                }
                debug("Modified C00:" + packet.key)
            }
        }

        if (spectate.get()) {
            if (packet is C03PacketPlayer) {
                packet.onGround = false

                mc.netHandler.addToSendQueue(C18PacketSpectate(mc.thePlayer.uniqueID))
                mc.netHandler.addToSendQueue(C13PacketPlayerAbilities(mc.thePlayer.capabilities))
                debug("Packet C18 + C13")
            }
            if (packet is C13PacketPlayerAbilities) {
                debug("Packet C13")
                packet.isFlying = true
                packet.isInvulnerable = true
                packet.isAllowFlying = true
                packet.isCreativeMode = false
            }
        }

        if (vulcancombat.get()) {
            if (packet is C0BPacketEntityAction && noC0BValue.get()) {
                event.cancelEvent()
                debug("C0B-EntityAction CANCELLED")
            }
            if (packet is C0FPacketConfirmTransaction) {
                BlinkUtils.setBlinkState(packetTransaction = false)
                val transUID = (packet.uid).toInt()
                if (transUID >= -25767 && transUID <= -24769) {
                    BlinkUtils.setBlinkState(packetTransaction = true)
                    debug("C0F-PingTickCounter IN ${BlinkUtils.bufferSize(packetType = "C0FPacketConfirmTransaction")}")
                } else if (transUID == -30000) {
                    BlinkUtils.setBlinkState(packetTransaction = true)
                    debug("C0F-OnSpawn IN ${BlinkUtils.bufferSize(packetType = "C0FPacketConfirmTransaction")}")
                }
            }
        }

        if (oldwatchdog2.get()) {
            canBlink = true

            if (mc.thePlayer.ticksExisted > 200f)
                inCage = false

            //timerA
            if (timerA.get() && inCage == false) {
                if (packet is C02PacketUseEntity || packet is C03PacketPlayer || packet is C07PacketPlayerDigging || packet is C08PacketPlayerBlockPlacement ||
                    packet is C0APacketAnimation || packet is C0BPacketEntityAction && mc.thePlayer.ticksExisted > strafePackets.get()
                ) {
                    if (timerShouldCancel) {
                        if (!timerCancelTimer.hasTimePassed(350)) {
                            packets.add(packet as Packet<INetHandlerPlayServer>)
                            event.cancelEvent()
                            canBlink = false
                        } else {
                            debug("Timer 1 release packets")
                            debug("Size " + packets.size.toString())
                            timerShouldCancel = false
                            while (!packets.isEmpty()) {
                                PacketUtils.sendPacketNoEvent(packets.take())
                            }
                        }
                        if ((mc.thePlayer.isUsingItem || !Client.moduleManager[KillAura::class.java]!!.autoBlockModeValue.get()
                                .equals("None")) && Client.moduleManager[KillAura::class.java]!!.target != null && mc.thePlayer.heldItem != null && mc.thePlayer.heldItem.item is ItemSword
                        ) {
                            debug("Timer 1 release packets")
                            debug("Size " + packets.size.toString())
                            timerShouldCancel = false
                            while (!packets.isEmpty()) {
                                PacketUtils.sendPacketNoEvent(packets.take())
                            }
                        }
                    }
                }
            }

            //timerB
            if (timerB.get() && inCage == false) {
                if (packet is C02PacketUseEntity || packet is C03PacketPlayer || packet is C07PacketPlayerDigging || packet is C08PacketPlayerBlockPlacement ||
                    packet is C0APacketAnimation || packet is C0BPacketEntityAction && mc.thePlayer.ticksExisted > strafePackets.get()
                ) {
                    if (timerShouldCancel) {
                        if (!timerCancelTimer.hasTimePassed(250)) {
                            packets.add(packet as Packet<INetHandlerPlayServer>)
                            event.cancelEvent()
                            canBlink = false
                        } else {
                            debug("Timer 2 release packets")
                            debug("Size " + packets.size.toString())
                            timerShouldCancel = false
                            while (!packets.isEmpty()) {
                                PacketUtils.sendPacketNoEvent(packets.take())
                            }
                        }
                        if ((mc.thePlayer.isUsingItem || !Client.moduleManager[KillAura::class.java]!!.autoBlockModeValue.get()
                                .equals("None")) && Client.moduleManager[KillAura::class.java]!!.target != null && mc.thePlayer.heldItem != null && mc.thePlayer.heldItem.item is ItemSword
                        ) {
                            debug("Timer 2 release packets")
                            debug("Size " + packets.size.toString())
                            timerShouldCancel = false
                            while (!packets.isEmpty()) {
                                PacketUtils.sendPacketNoEvent(packets.take())
                            }
                        }
                    }
                }
            }


            // noC03
            if (packet is C03PacketPlayer && !(packet is C05PacketPlayerLook || packet is C06PacketPlayerPosLook || packet is C04PacketPlayerPosition) && noC03.get()) {
                event.cancelEvent()
                canBlink = false
            }

            // strafe disabler
            if (strafeDisabler.get() && (mc.thePlayer.ticksExisted < strafePackets.get()) && packet is C03PacketPlayer && (mc.thePlayer.ticksExisted % 15 != 0)) {
                event.cancelEvent()
                canBlink = false
            }

            // anti ban
            if (watchDogAntiBan.get() || (strafeDisabler.get() && (mc.thePlayer.ticksExisted < strafePackets.get()))) {
                if (event.packet is C06PacketPlayerPosLook && mc.thePlayer.onGround && mc.thePlayer.fallDistance > 10) {
                    if (counter > 0) {
                        if (event.packet.x == x && event.packet.y == y && event.packet.z == z) {
                            mc.netHandler.networkManager.sendPacket(
                                C04PacketPlayerPosition(
                                    event.packet.x,
                                    event.packet.y,
                                    event.packet.z,
                                    event.packet.onGround
                                )
                            )
                            debug("Packet C04")
                            event.cancelEvent()
                        }
                    }
                    counter += 1

                    if (event.packet is C05PacketPlayerLook && mc.thePlayer.isRiding) {
                        mc.netHandler.addToSendQueue(
                            C0BPacketEntityAction(
                                mc.thePlayer,
                                C0BPacketEntityAction.Action.START_SPRINTING
                            )
                        )
                        debug("Packet C0B")
                    } else if (event.packet is C0CPacketInput && mc.thePlayer.isRiding) {
                        mc.netHandler.networkManager.sendPacket(event.packet)
                        mc.netHandler.addToSendQueue(
                            C0BPacketEntityAction(
                                mc.thePlayer,
                                C0BPacketEntityAction.Action.STOP_SNEAKING
                            )
                        )
                        debug("Packet C0B")
                        event.cancelEvent()
                    }
                }

                if (event.packet is S08PacketPlayerPosLook) {
                    val s08 = event.packet
                    x = s08.x
                    y = s08.y
                    z = s08.z
                    debug("Receive S08")
                }

                if (event.packet is S07PacketRespawn) {
                    counter = 0
                }
            }
        }

        if (inventoryspoof.get()) {
            if (packet is C0DPacketCloseWindow) {
                event.cancelEvent()
                debug("spoof inventory")
            }
        }

        if (mushmc.get()) {
            if (packet is C16PacketClientStatus || packet is C0APacketAnimation || packet is S42PacketCombatEvent || packet is S3EPacketTeams) {
                event.cancelEvent()
                debug("funny packet")
            }
            mc.thePlayer.capabilities.isCreativeMode = true
        }

        if (cubecraft.get()) {
            if (packet is C03PacketPlayer && mc.currentScreen == null) {
                PacketUtils.sendPacketNoEvent(
                    C08PacketPlayerBlockPlacement(
                        BlockPos(mc.thePlayer).down(5),
                        EnumFacing.UP.index,
                        null,
                        0.0f,
                        1.0f,
                        0.0f
                    )
                )
                debug("disable")
            } else if (packet is C00PacketKeepAlive) {
                event.cancelEvent()
                debug("fix")
            }
        }

        if (input.get()) {
            PacketUtils.sendPacketNoEvent(C0CPacketInput(0.98f, 0f, true, true))
            debug("input")
        }

        if (vulcanautoblock.get()) {
            if (packet is C17PacketCustomPayload) {
                event.cancelEvent()
                debug("fix autoblock packets")
            }
        }

        if (vulcanstrafe.get()) {
            if (packet is C03PacketPlayer) {
                c03Counter++
                if (packet.isMoving) {
                    if (c03Counter >= delayValue.get()) {
                        debug("packet 1")
                        PacketUtils.sendPacketNoEvent(
                            C07PacketPlayerDigging(
                                C07PacketPlayerDigging.Action.STOP_DESTROY_BLOCK,
                                if (avoidPhaseBpValue.get()) {
                                    BlockPos.ORIGIN
                                } else {
                                    BlockPos(mc.thePlayer.posX, mc.thePlayer.posY, mc.thePlayer.posZ)
                                }, EnumFacing.DOWN
                            )
                        )
                        c03Counter = 0
                    } else if (c03Counter == delayValue.get() - 2) {
                        debug("packet 2")
                        PacketUtils.sendPacketNoEvent(
                            C07PacketPlayerDigging(
                                C07PacketPlayerDigging.Action.START_DESTROY_BLOCK,
                                BlockPos.ORIGIN, EnumFacing.DOWN
                            )
                        )
                    }
                }
            }
        }

        if (spartancombat.get()) {
            if (packet is C00PacketKeepAlive && (keepAlives.size <= 0 || packet != keepAlives[keepAlives.size - 1])) {
                debug("c00 added")
                keepAlives.add(packet)
                event.cancelEvent()
            }
            if (packet is C0FPacketConfirmTransaction && (transactions.size <= 0 || packet != transactions[transactions.size - 1])) {
                debug("c0f added")
                transactions.add(packet)
                event.cancelEvent()
            }
        }

        if (heirteirac.get()) {
            if (mc.thePlayer.ticksExisted < 120)
                return

            if (packet is S08PacketPlayerPosLook) {
                val x = packet.x - mc.thePlayer.posX
                val y = packet.y - mc.thePlayer.posY
                val z = packet.z - mc.thePlayer.posZ
                val diff = sqrt(x * x + y * y + z * z)
                if (diff < 12) {
                    event.cancelEvent()
                    PacketUtils.sendPacketNoEvent(
                        C06PacketPlayerPosLook(
                            packet.x,
                            packet.y,
                            packet.z,
                            packet.getYaw(),
                            packet.getPitch(),
                            !mc.theWorld.isAirBlock(BlockPos(packet.x, packet.y - 0.1, packet.z))
                        )
                    )
                }
            }
        }

        if (intave.get()) {
            if (packet is C00PacketKeepAlive) {
                event.cancelEvent()

                this.linkedQueue.add(event.packet)
            }

            if (packet is C0FPacketConfirmTransaction) {

                if (packet.getUid() > 0 && packet.getUid() < 75) {
                    debug("funny intave moment")
                    return
                }

                this.linkedQueue.add(event.packet)
                event.cancelEvent()
            }

            if (mc.thePlayer != null && mc.thePlayer.ticksExisted < 8) {
                this.linkedQueue.clear()
                this.timer.reset()
            }
        }

        if (funcraftstaff.get()) {
            if (packet is C03PacketPlayer) {
                mc.thePlayer.sendQueue.networkManager.sendPacket(C00PacketKeepAlive(-2))
                debug("LOL")
            }
        }

        if (basic.get()) {
            if (packet is C00PacketKeepAlive) {
                debug("cancel c00")
                event.cancelEvent()
            }
            if (packet is C0FPacketConfirmTransaction) {
                debug("cancel c0f")
                event.cancelEvent()
            }
        }

        if (oldmatrix.get()) {
            if (packet is C03PacketPlayer && mc.thePlayer.ticksExisted % 15 == 0) {
                try {
                    val b = ByteArrayOutputStream()
                    val _out = DataOutputStream(b)
                    _out.writeUTF(mc.thePlayer.gameProfile.name)
                    val buf = PacketBuffer(Unpooled.buffer())
                    buf.writeBytes(b.toByteArray())
                    mc.netHandler.addToSendQueue(C17PacketCustomPayload("matrix:geyser", buf))

                    debug("Sent Matrix spoof packet.")
                } catch (e: IOException) {
                    debug("Error occurred.")
                }
            }
        }

        if (tubnet.get()) {
            if (packet is C03PacketPlayer && mc.thePlayer.ticksExisted % 15 == 0) {
                try {
                    val b = ByteArrayOutputStream()
                    val _out = DataOutputStream(b)
                    _out.writeUTF(mc.thePlayer.gameProfile.name)
                    val buf = PacketBuffer(Unpooled.buffer())
                    buf.writeBytes(b.toByteArray())
                    mc.netHandler.addToSendQueue(C17PacketCustomPayload("matrix:geyser", buf))

                    debug("packet 1")
                } catch (e: IOException) {
                    debug("packet fix")
                }
                if (mc.thePlayer == null || disableLogger) return
                if (packet is C03PacketPlayer) // Cancel all movement stuff
                    event.cancelEvent()
                if (packet is C04PacketPlayerPosition || packet is C06PacketPlayerPosLook ||
                    packet is C08PacketPlayerBlockPlacement ||
                    packet is C0APacketAnimation ||
                    packet is C0BPacketEntityAction || packet is C02PacketUseEntity
                ) {
                    event.cancelEvent()
                    packets.add(packet)
                }
            }
        }

        if (blockdrop.get()) {
            if (packet is C00PacketKeepAlive && (keepAlives.size <= 0 || packet != keepAlives[keepAlives.size - 1])) {
                debug("c00 added")
                keepAlives.add(packet)
                event.cancelEvent()
            }
            if (packet is C0FPacketConfirmTransaction && (transactions.size <= 0 || packet != transactions[transactions.size - 1])) {
                debug("c0f added")
                transactions.add(packet)
                event.cancelEvent()
            }
            if (packet is C13PacketPlayerAbilities && staffValue.get()) {
                event.cancelEvent()
            }
        }

        if (jump.get()) {
            if (packet is C03PacketPlayer) {
                val capabilities = PlayerCapabilities()
                capabilities.disableDamage = false
                capabilities.isFlying = true
                capabilities.allowFlying = false
                capabilities.isCreativeMode = false
                mc.netHandler.addToSendQueue(C13PacketPlayerAbilities(capabilities))
                debug("jump added")
            }
        }

        if (gwencombat.get()) {
            if (packet is C00PacketKeepAlive) {
                event.cancelEvent()
                PacketUtils.sendPacketNoEvent(
                    C00PacketKeepAlive(
                        packet.key - RandomUtils.nextInt(
                            1000,
                            2147483647
                        )
                    )
                )
                debug("cancel c00")
            }
        }

        if (latestverus.get()) {
            if (!shouldRun()) {
                msTimer.reset()
                packetQueue.clear()
                return
            }

            if (packet is C0FPacketConfirmTransaction && !isInventory(packet.uid)) {
                packetQueue.add(packet)
                event.cancelEvent()
                if (packetQueue.size > verusBufferSizeValue.get()) {
                    if (!shouldActive) {
                        shouldActive = true
                        Client.hud.addNotification(
                            Notification(
                                "Successfully Verus Disabled!",
                                Notification.Type.SUCCESS
                            )
                        )
                    }
                    PacketUtils.sendPacketNoEvent(packetQueue.poll())
                }
                debug("c0f, ${packetQueue.size}")
            }

            if (packet is C0BPacketEntityAction) {
                event.cancelEvent()
                debug("ignored packet action")
            }

            if (packet is C03PacketPlayer) {
                if (verusFlagValue.get() && mc.thePlayer.ticksExisted % verusFlagDelayValue.get() == 0) {
                    debug("modified c03")
                    packet.y -= 11.015625 // just phase into ground instead (minimum to flag)
                    packet.onGround = false
                    packet.isMoving = false
                }
                if (verusValidPos.get() && packet is C03PacketPlayer) {
                    if (packet.y % 0.015625 == 0.0) {
                        packet.onGround = true
                        debug("true asf")
                    }
                }
            }

            if (packet is S08PacketPlayerPosLook && verusSlientFlagApplyValue.get()) {
                val x = packet.x - mc.thePlayer.posX
                val y = packet.y - mc.thePlayer.posY
                val z = packet.z - mc.thePlayer.posZ
                val diff = sqrt(x * x + y * y + z * z)
                if (diff <= 8) {
                    event.cancelEvent()
                    // verus, why
                    debug("flag silent accept")
                    PacketUtils.sendPacketNoEvent(
                        C06PacketPlayerPosLook(
                            packet.x,
                            packet.y,
                            packet.z,
                            packet.getYaw(),
                            packet.getPitch(),
                            false
                        )
                    )
                }
            }
        }

        if (silentaccept.get()) {
            if (packet is C03PacketPlayer) {
                val yPos = round(mc.thePlayer.posY / 0.015625) * 0.015625
                mc.thePlayer.setPosition(mc.thePlayer.posX, yPos, mc.thePlayer.posZ)

                if (mc.thePlayer.ticksExisted % 45 == 0) {
                    debug("flag")
                    PacketUtils.sendPacketNoEvent(
                        C04PacketPlayerPosition(
                            mc.thePlayer.posX,
                            mc.thePlayer.posY,
                            mc.thePlayer.posZ,
                            true
                        )
                    )
                    PacketUtils.sendPacketNoEvent(
                        C04PacketPlayerPosition(
                            mc.thePlayer.posX,
                            mc.thePlayer.posY - 11.725,
                            mc.thePlayer.posZ,
                            false
                        )
                    )
                    PacketUtils.sendPacketNoEvent(
                        C04PacketPlayerPosition(
                            mc.thePlayer.posX,
                            mc.thePlayer.posY,
                            mc.thePlayer.posZ,
                            true
                        )
                    )
                }
            }

            if (packet is S08PacketPlayerPosLook) {
                if (mc.thePlayer == null || mc.thePlayer.ticksExisted <= 0) return

                var x = packet.getX() - mc.thePlayer.posX
                var y = packet.getY() - mc.thePlayer.posY
                var z = packet.getZ() - mc.thePlayer.posZ
                var diff = sqrt(x * x + y * y + z * z)
                if (diff <= 8) {
                    event.cancelEvent()
                    PacketUtils.sendPacketNoEvent(
                        C06PacketPlayerPosLook(
                            packet.getX(),
                            packet.getY(),
                            packet.getZ(),
                            packet.getYaw(),
                            packet.getPitch(),
                            true
                        )
                    )

                    debug("silent s08 accept")
                }
            }

            if (packet is C0FPacketConfirmTransaction && !isInventory(packet.uid)) {
                repeat(4) {
                    packetQueue.add(packet)
                }
                event.cancelEvent()
                debug("c0f dupe: 4x")
            }
        }

        if (buzzsemi.get()) {
            if (packet is C0FPacketConfirmTransaction) {
                repeat(5) {
                    packetQueue.add(packet)
                }
                event.cancelEvent()
                debug("c0f dupe: 5x")
            }
        }

        if (veruscombat.get()) {
            if (packet is C0FPacketConfirmTransaction) {
                event.cancelEvent()
                debug("cancel c0f")
            } else if (packet is C0BPacketEntityAction) {
                event.cancelEvent()
                debug("cancel c0b")
            }
        }

        if (verussemi.get()) {
            if (!shouldRun()) {
                queueBus.clear()
                return
            }

            if (packet is C0BPacketEntityAction) {
                event.cancelEvent()
                debug("cancel action")
            }

            if (packet is S08PacketPlayerPosLook) {
                if (mc.thePlayer.getDistance(packet.x, packet.y, packet.z) < 8) {
                    PacketUtils.sendPacketNoEvent(
                        C06PacketPlayerPosLook(
                            packet.x,
                            packet.y,
                            packet.z,
                            packet.yaw,
                            packet.pitch,
                            false
                        )
                    )
                    event.cancelEvent()
                    debug("silent flag")
                }
            }

            if (packet is C00PacketKeepAlive || (packet is C0FPacketConfirmTransaction && !isInventory(packet.uid))) {
                queueBus.add(packet as Packet<INetHandlerPlayServer>)
                event.cancelEvent()

                debug("c0f or c00, ${queueBus.size}")

                if (queueBus.size > 300) {
                    PacketUtils.sendPacketNoEvent(queueBus.poll())
                    debug("poll")
                }
            }

            if (packet is C03PacketPlayer) {
                if (mc.thePlayer.ticksExisted % 20 == 0) {
                    PacketUtils.sendPacketNoEvent(C0CPacketInput(0.98f, 0.98f, false, false))
                    debug("c18 and c0c")
                }

                if (mc.thePlayer.ticksExisted % 45 == 0) {
                    packet.y = -0.015625
                    packet.onGround = false
                    packet.isMoving = false
                    debug("flag packet")
                }
            }
        }

        if (flag.get()) {
            if (packet is C03PacketPlayer && flagMode.get().equals(
                    "edit",
                    true
                ) && mc.thePlayer.ticksExisted > 0 && mc.thePlayer.ticksExisted % flagTick.get() == 0
            ) {
                packet.isMoving = false
                packet.onGround = false
                packet.y = -0.08

                debug("flagged")
            }
            if (packet is S08PacketPlayerPosLook && flagSilent.get()) {
                if (mc.thePlayer == null || mc.thePlayer.ticksExisted <= 0) return

                var x = packet.getX() - mc.thePlayer.posX
                var y = packet.getY() - mc.thePlayer.posY
                var z = packet.getZ() - mc.thePlayer.posZ
                var diff = sqrt(x * x + y * y + z * z)
                if (diff <= 8) {
                    event.cancelEvent()
                    PacketUtils.sendPacketNoEvent(
                        C06PacketPlayerPosLook(
                            packet.getX(),
                            packet.getY(),
                            packet.getZ(),
                            packet.getYaw(),
                            packet.getPitch(),
                            true
                        )
                    )

                    debug("silent s08 accept")
                }
            }
        }

        if (pingspoof.get()) {
            if (packet is C0FPacketConfirmTransaction && !isInventory(packet.uid)) {
                queueBus.add(packet)
                event.cancelEvent()

                debug("c0f added, action id ${packet.uid}, target id ${packet.windowId}")
            }
            if (packet is C00PacketKeepAlive) {
                queueBus.add(packet)
                event.cancelEvent()

                debug("c00 added, key ${packet.key}")
            }
        }

        if (matrix.get()) {
            if (matrixNoCheck.get() || Client.moduleManager.getModule(Speed::class.java)!!.state || Client.moduleManager.getModule(
                    Flight::class.java
                )!!.state
            ) {
                if (packet is C03PacketPlayer) {
                    if (matrixNoMovePacket.get() && !packet.isMoving) {
                        event.cancelEvent()
                        debug("no move, cancelled")
                        return
                    }
                    if (matrixMoveFix.get()) {
                        // almost completely disable strafe check, nofall
                        packet.onGround = true
                        if (!packet.rotating) { // fix fly sometimes doesn't land properly since most mc servers all refer to C04, C05, C06 as C03s aka. PacketPlayerInFlying.
                            packet.rotating = true
                            packet.yaw = mc.thePlayer.rotationYaw
                            packet.pitch = mc.thePlayer.rotationPitch
                        }
                    }
                }
            }
        }

        if (oldwatchdog1.get()) {
            if (mc.isSingleplayer) return

            if (autoAlert.get() && packet is S02PacketChat && packet.chatComponent.unformattedText
                    .contains("Cages opened!", true)
            )
                Client.hud.addNotification(
                    Notification(
                        "Speed is bannable until this notification disappears.",
                        Notification.Type.WARNING,
                        20000L
                    )
                )

            if (testFeature.get() && !ServerUtils.isHypixelLobby()) {
                if (packet is C0FPacketConfirmTransaction && (!checkValid.get() || !isInventory(packet.uid))) {
                    event.cancelEvent()
                    packetQueue.add(packet)

                    debug("c0f, ${packet.uid} ID, ${packet.windowId} wID")

                    if (!shouldActive) {
                        shouldActive = true
                        debug("activated")
                        when (waitingDisplayMode.get().lowercase(Locale.getDefault())) {
                            "notification" -> Client.hud.addNotification(
                                Notification(
                                    "Activated Disabler.",
                                    Notification.Type.SUCCESS,
                                    2000L
                                )
                            )

                            "chat" -> debug("Activated Disabler.", true)
                        }
                    }
                }
                if (packet is C00PacketKeepAlive) {
                    event.cancelEvent()
                    anotherQueue.add(packet)

                    wdTimer.reset()
                    debug("c00, ${packet.key}")
                }
                if (packet is C03PacketPlayer || packet is C0BPacketEntityAction || packet is C08PacketPlayerBlockPlacement || packet is C0APacketAnimation) {
                    if (!shouldActive)
                        event.cancelEvent()
                }
                if (packet is S08PacketPlayerPosLook && !shouldActive) {
                    if (alrSendY) {
                        //mc.netHandler.addToSendQueue(C06PacketPlayerPosLook(packet.getX(), packet.getY(), packet.getZ(), packet.getYaw(), packet.getPitch(), false))
                        event.cancelEvent()
                        debug("no s08")
                    } else {
                        alrSendY = true
                        debug("first s08, ignore")
                    }
                }
            }

            if (noC03s.get() && packet is C03PacketPlayer)
                if (packet !is C04PacketPlayerPosition && packet !is C05PacketPlayerLook && packet !is C06PacketPlayerPosLook)
                    event.cancelEvent()
        }

        if (hycraft.get()) {
            if (packet is S3EPacketTeams) {
                debug("anticrash")
                event.cancelEvent()
            }
        }

        if (vanilladesync.get()) {
            if (packet is S08PacketPlayerPosLook) {
                if (!mc.netHandler.doneLoadingTerrain) {
                    debug("not loaded terrain yet")
                    return
                }
                event.cancelEvent()
                PacketUtils.sendPacketNoEvent(C04PacketPlayerPosition(packet.x, packet.y, packet.z, false))
                mc.thePlayer.setPosition(packet.x, packet.y, packet.z)
                debug("silent setback")
            }
        }
    }

    private fun updateLagTime() {
        decTimer.reset()
        lagTimer.reset()
        currentDelay =
            if (dynamicValue.get()) RandomUtils.nextInt(decDelayMinValue.get(), decDelayMaxValue.get()) else 5000
        currentDec = if (compDecValue.get()) statDecValue.get() else -1
        currentBuffer = minBuffValue.get()
    }

    private fun blink() {
        try {
            disableLogger = true
            while (!packets.isEmpty()) {
                mc.netHandler.networkManager.sendPacket(packets.take())
            }
            disableLogger = false
        } catch (e: Exception) {
            e.printStackTrace()
            disableLogger = false
        }
    }

    private fun getNearBoat(): Entity? {
        val entities = mc.theWorld.loadedEntityList
        for (entity_ in entities) {
            if (entity_ is EntityBoat) {
                if (entity_ != mc.thePlayer.ridingEntity) {
                    return entity_
                }
            }
        }
        return null
    }

    fun flush(check: Boolean) {
        if ((if (check) psfSendMode.get() else psfStartSendMode.get()).equals("all", true))
            while (queueBus.size > 0) {
                PacketUtils.sendPacketNoEvent(queueBus.poll())
            }
        else
            PacketUtils.sendPacketNoEvent(queueBus.poll())
    }

    @EventTarget(priority = 2)
    fun onMotion(event: MotionEvent) {
        val speed = Client.moduleManager.getModule(Speed::class.java)!!
        val fly = Client.moduleManager.getModule(Flight::class.java)!!

        if (event.eventState == EventState.PRE)
            shouldModifyRotation = false

        if (universocraft.get()) {
            if (Client.moduleManager.getModule(Speed::class.java)?.state!!) {
                RotationUtils.setTargetRotation(Rotation(0F, 30F))
            }
        }

        if (payload.get()) {
            if (event.eventState != EventState.POST) {
                PacketUtils.sendPacketNoEvent(
                    C17PacketCustomPayload(
                        "40413eb1",
                        PacketBuffer(Unpooled.wrappedBuffer(byteArrayOf(8, 52, 48, 52, 49, 51, 101, 98, 49)))
                    )
                )
                debug("funny")
            }
        }

        if (oldwatchdog2.get()) {
            if (rotationChanger.get() && !Client.moduleManager[Scaffold::class.java]!!.state && !Client.moduleManager[KillAura::class.java]!!.state) {
                val cYaw = MovementUtilsFix.movingYaw
                RotationUtils.setTargetRotation(Rotation(cYaw, mc.thePlayer.rotationPitch), 10)
            }
        }

        if (oldwatchdog1.get()) {
            if (event.eventState == EventState.PRE) {
                if ((speed.state || fly.state) && rotModify.get()) {
                    shouldModifyRotation = true
                    if (MovementUtils.isMoving()) {
                        val cYaw = MovementUtils.getPredictionYaw(event.x, event.z) - 90F

                        lastYaw = cYaw
                        event.yaw = cYaw
                        if (tifality90.get()) event.pitch = 90F
                        RotationUtils.setTargetRotation(Rotation(cYaw, if (tifality90.get()) 90F else event.pitch))
                    } else if (noMoveKeepRot.get()) {
                        event.yaw = lastYaw
                        if (tifality90.get()) event.pitch = 90F
                        RotationUtils.setTargetRotation(
                            Rotation(
                                lastYaw,
                                if (tifality90.get()) 90F else event.pitch
                            )
                        )
                    }
                }
                if (mc.isSingleplayer) return
                if (testFeature.get() && !ServerUtils.isHypixelLobby()) {
                    if (shouldActive && wdTimer.hasTimePassed(testDelay.get().toLong())) {
                        while (!anotherQueue.isEmpty()) {
                            PacketUtils.sendPacketNoEvent(anotherQueue.poll())
                            debug("c00, ${anotherQueue.size}")
                        }
                        while (!packetQueue.isEmpty()) {
                            PacketUtils.sendPacketNoEvent(packetQueue.poll())
                            debug("c0f, ${packetQueue.size}")
                        }
                    }
                }
            }
        }

        if (event.eventState == EventState.POST && (!matrixMoveOnly.get() || isMoving())) // check post event
            if (matrix.get()) {
                if (matrixNoCheck.get() || Client.moduleManager.getModule(Flight::class.java)!!.state || Client.moduleManager.getModule(
                        Speed::class.java
                    )!!.state
                ) {
                    var changed = false
                    if (matrixHotbarChange.get()) for (i in 0..8) {
                        // find a empty inventory slot
                        if (mc.thePlayer.inventory.mainInventory[i] == null && i != mc.thePlayer.inventory.currentItem) {
                            PacketUtils.sendPacketNoEvent(C09PacketHeldItemChange(i))
                            changed = true
                            debug("found empty slot $i, switching")
                            break
                        }
                    }

                    PacketUtils.sendPacketNoEvent(
                        C06PacketPlayerPosLook(
                            mc.thePlayer.posX,
                            mc.thePlayer.posY,
                            mc.thePlayer.posZ,
                            RotationUtils.serverRotation?.yaw!!,
                            RotationUtils.serverRotation?.pitch!!,
                            mc.thePlayer.onGround
                        )
                    )
                    mc.netHandler.addToSendQueue(
                        C08PacketPlayerBlockPlacement(
                            BlockPos(-1, -1, -1),
                            -1,
                            null,
                            0f,
                            0f,
                            0f
                        )
                    )
                    debug("sent placement")

                    if (changed) {
                        PacketUtils.sendPacketNoEvent(C09PacketHeldItemChange(mc.thePlayer.inventory.currentItem))
                        debug("switched back")
                    }
                }
            }
    }

    @EventTarget
    fun onUpdate(event: UpdateEvent) {
        val flight = Client.moduleManager.getModule(Flight::class.java)

        if (boat.get()) {
            if (mc.thePlayer.ridingEntity != null) {
                mc.thePlayer.rotationPitch = (90.0).toFloat()
                mc.thePlayer.swingItem()
                mc.playerController.attackEntity(mc.thePlayer, mc.thePlayer.ridingEntity)
                mc.thePlayer.swingItem()
                mc.playerController.attackEntity(mc.thePlayer, getNearBoat())
                canModify = true
                debug("Destroy Boat")
            }
        }

        if (vulcancombat.get()) {
            if (runReset) {
                runReset = false
                PacketUtils.sendPacketNoEvent(
                    C0BPacketEntityAction(
                        mc.thePlayer,
                        C0BPacketEntityAction.Action.STOP_SPRINTING
                    )
                )
            }
            if (lagTimer.hasTimePassed(currentDelay.toLong()) && BlinkUtils.bufferSize(packetType = "C0FPacketConfirmTransaction") > currentBuffer) {
                updateLagTime()
                BlinkUtils.releasePacket(packetType = "C0FPacketConfirmTransaction", minBuff = currentBuffer)
                debug("C0F-PingTickCounter RELEASE")
            }
            if (decTimer.hasTimePassed(currentDec.toLong()) && currentDec > 0) {
                BlinkUtils.releasePacket(packetType = "C0FPacketConfirmTransaction", amount = 1)
                debug("C0F-PingTickCounter DECREASE")
                decTimer.reset()
            }
        }

        if (oldwatchdog2.get()) {
            // timer1
            if (timerA.get()) {
                if (timerCancelDelay.hasTimePassed(5000)) {
                    timerShouldCancel = true
                    timerCancelTimer.reset()
                    timerCancelDelay.reset()
                }
            }

            // timer2
            if (timerB.get()) {
                if (timerCancelDelay.hasTimePassed(2000)) {
                    timerShouldCancel = true
                    timerCancelTimer.reset()
                    timerCancelDelay.reset()
                }
            }


            //Hypixel Disabler C00
            if (c00Disabler.get()) {
                if (mc.thePlayer.onGround && ClassUtils.isBlockUnder() && mc.thePlayer.fallDistance > 10) {
                    mc.netHandler.addToSendQueue(C00PacketKeepAlive(RandomUtils.nextInt(0, 1000)))
                    debug("Hypixel Disabler C00")
                }
            }

            //Hypixel Disabler C0B & Hypixel Disabler C03
            if (c0BDisabler.get()) {
                if (mc.thePlayer.ticksExisted % 180 == 90) {
                    if (mc.thePlayer.fallDistance > 10) {
                        mc.netHandler.addToSendQueue(C00PacketKeepAlive(RandomUtils.nextInt(0, 1000)))
                        debug("Hypixel Disabler C0B")
                        mc.timer.timerSpeed = 0.8f
                    } else {
                        if (mc.thePlayer.fallDistance < 10) {
                            if (mc.thePlayer.posY == mc.thePlayer.fallDistance.toDouble()) {
                                mc.netHandler.addToSendQueue(C03PacketPlayer(false))
                                if (mc.thePlayer.onGround) mc.timer.timerSpeed = 0.4f
                                if (mc.thePlayer.fallDistance == 0f) mc.netHandler.addToSendQueue(
                                    C03PacketPlayer(true)
                                )
                                debug("Hypixel Disabler C03")
                            }
                        }
                    }
                }
            }
        }

        if (intave.get()) {
            if (mc.thePlayer == null) {
                return
            }

            if (mc.thePlayer.ticksExisted < 3) {
                this.linkedQueue.clear()
                this.timer.reset()
            }

            if (!this.linkedQueue.isEmpty()) {
                this.linkedQueue.poll()

            }

            this.timer.reset()
        }

        if (heirteirac.get()) {
            if (mc.thePlayer.ticksExisted < 120)
                return
            mc.netHandler.addToSendQueue(
                C04PacketPlayerPosition(
                    mc.thePlayer.posX, mc.thePlayer.posY, mc.thePlayer.posZ, false
                )
            )
            mc.netHandler.addToSendQueue(
                C04PacketPlayerPosition(
                    mc.thePlayer.posX, mc.thePlayer.posY + 490, mc.thePlayer.posZ, true
                )
            )
        }

        if (spartancombat.get()) {
            if (msTimer.hasTimePassed(3000L) && keepAlives.size > 0 && transactions.size > 0) {
                PacketUtils.sendPacketNoEvent(keepAlives[keepAlives.size - 1])
                PacketUtils.sendPacketNoEvent(transactions[transactions.size - 1])
                debug("c00 no.${keepAlives.size - 1} sent.")
                debug("c0f no.${transactions.size - 1} sent.")
                keepAlives.clear()
                transactions.clear()
                msTimer.reset()
            }
        }

        if (tubnet.get()) {
            if (pulseTimer.hasTimePassed(60.toLong()) && flight!!.state) {
                blink()
                pulseTimer.reset()
                debug("funny packet")
            }
        }

        if (blockdrop.get()) {
            if (msTimer.hasTimePassed(3000L) && keepAlives.size > 0 && transactions.size > 0) {
                PacketUtils.sendPacketNoEvent(keepAlives[keepAlives.size - 1])
                PacketUtils.sendPacketNoEvent(transactions[transactions.size - 1])

                debug("c00 no.${keepAlives.size - 1} sent.")
                debug("c0f no.${transactions.size - 1} sent.")
                keepAlives.clear()
                transactions.clear()
                msTimer.reset()
            }
        }

        if (silentaccept.get()) {
            if (mc.thePlayer.ticksExisted % 180 == 0) {
                while (packetQueue.size > 22) {
                    PacketUtils.sendPacketNoEvent(packetQueue.poll())
                }
                debug("pushed queue until size < 22.")
            }
        }

        if (latestverus.get()) {
            if (verusAntiFlyCheck.get() && !shouldActive) {
                val flyMod = Client.moduleManager[Flight::class.java]!!
                if (flyMod.state) {
                    flyMod.state = false
                    Client.hud.addNotification(
                        Notification(
                            "You can't fly before successful activation.",
                            Notification.Type.WARNING
                        )
                    )
                    debug("no fly allowed")
                }
            }
            if (mc.thePlayer.ticksExisted % 15 == 0 && shouldRun()) {
                if (verusFakeInput.get()) {
                    mc.netHandler.addToSendQueue(
                        C0CPacketInput(
                            mc.thePlayer.moveStrafing.coerceAtMost(0.98F),
                            mc.thePlayer.moveForward.coerceAtMost(0.98F),
                            mc.thePlayer.movementInput.jump,
                            mc.thePlayer.movementInput.sneak
                        )
                    )
                    debug("c0c")
                }
            }
        }

        if (pingspoof.get()) {
            if (msTimer.hasTimePassed(psfWorldDelay.get().toLong()) && !shouldActive) {
                shouldActive = true
                sendDelay = RandomUtils.nextInt(minpsf.get(), maxpsf.get())
                if (queueBus.size > 0) flush(false)
                msTimer.reset()
                debug("activated. expected next delay: ${sendDelay}ms")
            }

            if (shouldActive) {
                if (msTimer.hasTimePassed(sendDelay.toLong()) && !queueBus.isEmpty()) {
                    flush(true)
                    sendDelay = RandomUtils.nextInt(minpsf.get(), maxpsf.get())
                    msTimer.reset()
                    debug("expected next delay: ${sendDelay}ms")
                }
            }
        }

        if (flag.get()) {
            if (flagMode.get().equals(
                    "packet",
                    true
                ) && mc.thePlayer.ticksExisted > 0 && mc.thePlayer.ticksExisted % flagTick.get() == 0
            ) {
                PacketUtils.sendPacketNoEvent(
                    C04PacketPlayerPosition(
                        mc.thePlayer.posX,
                        -0.08,
                        mc.thePlayer.posZ,
                        mc.thePlayer.onGround
                    )
                )
                debug("flagged")
            }
        }
    }
}